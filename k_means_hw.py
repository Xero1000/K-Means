# -*- coding: utf-8 -*-
"""K-Means HW.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tq4mPZ8dmk9bjnJp-WM99zNwda-Y1rjy
"""

import matplotlib.pyplot as plt
import numpy as np
from matplotlib import style
import random
import math
import statistics

# Toy dataset
X = np.array([[2, 4],
[1.7, 2.8],
[7, 8],
[8.6, 8],
[3.4, 1.5],
[9,11]])
plt.scatter(X[:,0], X[:,1], s=150)
plt.show()

# the previous centroids
red_centroid = []
blue_centroid = []

firstLoop = True

# the new centroids
new_red_centroid = []
new_blue_centroid = []

# if the new centroid and previous centroid's difference is less than the threshold,
# 3 times in a row, the best centroid has been found
red_minimal_centroid_difference_counter = 0
blue_minimal_centroid_difference_counter = 0

# This function randomly selects two points from the dataset as the initial centroids
def getInitialCentroids():
  unique = False # Becomes true if the two centroids are not the same
  global red_centroid
  global blue_centroid
  red_index = random.randint(0, 5) # A random index value is generated for the red centroid
  red_centroid = X[red_index] # the point in the red index position is the initial red centroid
  while unique == False: # Loop terminates if the two centroids are not equal
    blue_index = random.randint(0, 5) # Random index value is generated for the blue centroid
    if blue_index != red_index: # Checks if the two centroids are unique
      unique = True
      blue_centroid = X[blue_index]

getInitialCentroids() # Function is called to get the initial centroids
red_points = [] # The points in the red cluster
blue_points = [] # The points in the blue cluster

# If the best red and blue centroids are found, they become true
# If both are True, then best becomes True
best_red_found = False 
best_blue_found = False
best = False

# Loop terminates when the centroids are no longer moving
while best == False:
  if firstLoop == False: # If statement runs for every loop after the first loop
    #Convert red and blue points to numpy array to use statistics.mean
    red_points = np.array(red_points)
    blue_points = np.array(blue_points)
    
    # Calculate the new red and blue centroids as well as their distance from
    # the previous centroids
    new_red_centroid = [statistics.mean(red_points[:,0]), statistics.mean(red_points[:,1])]
    red_centroids_distance = math.sqrt((new_red_centroid[0] - red_centroid[0])**2 + (new_red_centroid[1] - red_centroid[1])**2)

    new_blue_centroid = [statistics.mean(blue_points[:,0]), statistics.mean(blue_points[:,1])]
    blue_centroids_distance = math.sqrt((new_blue_centroid[0] - blue_centroid[0])**2 + (new_blue_centroid[1] - blue_centroid[1])**2)

    # If the centroids move less than 0.1 three times in a row, 
    # the best centroids have been found
    if red_centroids_distance < 0.1:
      red_minimal_centroid_difference_counter += 1
      if red_minimal_centroid_difference_counter >= 3:
        best_red_found = True
    else:
      red_minimal_centroid_difference_counter = 0

    if blue_centroids_distance < 0.1:
      blue_minimal_centroid_difference_counter += 1
      if blue_minimal_centroid_difference_counter >= 3:
        best_blue_found = True
    else:
      blue_minimal_centroid_difference_counter = 0

    if best_blue_found == True and best_red_found == True:
      best = True 

  # The lists holding the points for the current cluster  
  red_points = []
  blue_points = []

  # Distance of each point to the centroids are calculated
  # The centroids themselves are ignored as points
  # The point is assigned to the cluster with the smaller centroid distance
  for x in X:
    if list(x) != list(red_centroid) and list(x) != list(blue_centroid):
      red_distance = math.sqrt((x[0] - red_centroid[0])**2 + (x[1] - red_centroid[1])**2)
      blue_distance = math.sqrt((x[0] - blue_centroid[0])**2 + (x[1] - blue_centroid[1])**2)

      if red_distance < blue_distance:
        red_points.append(x)
      else:
        blue_points.append(x)

  # If either cluster is empty, the initial centroids are recalculated 
  if red_points == [] or blue_points == []:
    getInitialCentroids()
    continue

  # The newly calculated centroids become the previous centroids for the next iteration
  if new_red_centroid != [] and new_blue_centroid != []:
    red_centroid = new_red_centroid
    blue_centroid = new_blue_centroid
  
  firstLoop = False # Set to false once the first iteration is complete

# The final centroids are appended to the clusters
red_points.append(red_centroid)
blue_points.append(blue_centroid)

# Convert to numpy arrays so scatterplot can be made
red_points = np.array(red_points)
blue_points = np.array(blue_points)

# Print the scatterplot showing the red and blue clusters
plt.scatter(red_points[:,0], red_points[:,1], color='red')
plt.scatter(blue_points[:,0], blue_points[:,1], color='blue')
plt.show()

# Print the coordinates of each point and centroid
print("Red Points\n")
print(red_points, '\n')
print("Red Centroid: ", red_centroid)
print("\nBlue points\n")
print(blue_points, '\n')
print("Blue Centroid: ", blue_centroid)